# Prefetching, prerendering, and service worker precaching

지난 몇 모듈에서 JavaScript 로딩 지연 및 이미지와 `<iframe>` 요소의 지연 로딩과 같은 개념을 발견했습니다. 리소스 로딩을 지연시키면 필요할 때 리소스를 다운로드하여 초기 페이지 로드 시 네트워크 및 CPU 사용량을 줄일 수 있습니다. 이는 초기 페이지 로드 시간을 개선할 수 있지만, 필요한 리소스가 이미 로드되지 않은 경우 후속 상호작용에 지연이 발생할 수 있습니다.

예를 들어, 페이지에 사용자 정의 날짜 선택기가 포함된 경우 사용자가 요소와 상호작용할 때까지 날짜 선택기의 리소스를 지연시킬 수 있습니다. 그러나 날짜 선택기의 리소스를 필요할 때 로드하면 네트워크 연결, 장치 기능 또는 둘 다에 따라 약간의 지연이 발생할 수 있습니다.

이는 약간 까다로운 균형입니다. 사용되지 않을 수 있는 리소스를 로드하여 대역폭을 낭비하고 싶지 않지만, 상호작용과 후속 페이지 로드를 지연시키는 것도 이상적이지 않을 수 있습니다. 다행히도 이러한 두 극단 사이에서 더 나은 균형을 찾기 위해 사용할 수 있는 여러 도구가 있으며, 이 모듈에서는 리소스를 미리 가져오기, 전체 페이지를 사전 렌더링하기, 서비스 워커를 사용하여 리소스를 사전 캐싱하는 등의 기술을 다룹니다.

## 낮은 우선 순위로 가까운 미래에 필요한 리소스를 미리 가져오기

리소스 힌트인 `<link rel="prefetch">`를 사용하여 이미지, 스타일시트 또는 JavaScript 리소스를 포함한 리소스를 미리 가져올 수 있습니다. prefetch 힌트는 브라우저에게 리소스가 가까운 미래에 필요할 가능성이 있음을 알립니다.

prefetch 힌트가 지정되면 브라우저는 현재 페이지에 필요한 리소스와 경쟁하지 않도록 최저 우선 순위로 해당 리소스에 대한 요청을 시작할 수 있습니다.

> [!NOTE]
> prefetch 리소스 힌트는 단지 힌트일 뿐입니다. 브라우저는 네트워크 품질, 시스템 수준의 기본 설정 또는 기타 요인에 따라 prefetch 힌트를 수용할지 여부를 결정할 수 있습니다.

리소스를 미리 가져오면 사용자가 가까운 미래에 필요한 리소스를 다운로드할 필요가 없으므로 사용자 경험이 개선됩니다. 리소스는 필요할 때 디스크 캐시에서 즉시 검색할 수 있습니다.

```html
<head>
  <!-- ... -->
  <link rel="prefetch" as="script" href="/date-picker.js">
  <link rel="prefetch" as="style" href="/date-picker.css">
  <!-- ... -->
</head>
```

위의 HTML 스니펫은 브라우저에게 유휴 상태일 때 date-picker.js와 date-picker.css를 미리 가져올 수 있음을 알립니다. JavaScript에서 사용자가 페이지와 상호작용할 때 리소스를 동적으로 미리 가져올 수도 있습니다.

prefetch는 Safari를 제외한 모든 최신 브라우저에서 지원되지만, Safari에서는 기능 플래그를 통해서만 사용할 수 있습니다. 모든 브라우저에서 작동하는 방식으로 웹사이트에 리소스를 미리 로드해야 할 강한 필요가 있고 서비스 워커를 사용 중인 경우, 이 모듈의 후반부에서 서비스 워커를 사용하여 리소스를 사전 캐싱하는 방법에 대해 읽어보세요.

## 미래 탐색 속도를 높이기 위해 페이지를 미리 가져오기

HTML 문서를 가리킬 때 as="document" 속성을 지정하여 페이지와 모든 하위 리소스를 미리 가져올 수도 있습니다:

```html
<link rel="prefetch" href="/page" as="document">
```

브라우저가 유휴 상태일 때 /page에 대한 낮은 우선 순위 요청을 시작할 수 있습니다.

> [!IMPORTANT]
> 일반적으로 교차 출처 문서를 미리 가져오기 위해 `<link rel="prefetch">`를 사용하는 것을 피하는 것이 좋습니다. 교차 출처 문서를 미리 가져오는 것과 관련된 중복 요청을 초래하는 열린 문제가 있습니다. 또한 인증된 세션에 대해 동적으로 생성된 HTML 응답과 같은 개인화된 동일 출처 문서를 미리 가져오는 것을 피해야 합니다. 이러한 리소스는 일반적으로 캐시되지 않으며 사용되지 않을 가능성이 높아 궁극적으로 대역폭을 낭비하게 됩니다.

Chromium 기반 브라우저에서는 Speculation Rules API를 사용하여 문서를 미리 가져올 수 있습니다. Speculation Rules는 페이지의 HTML에 포함되거나 JavaScript를 통해 동적으로 추가된 JSON 객체로 정의됩니다:

```html
<script type="speculationrules">
{
  "prefetch": [{
    "source": "list",
    "urls": ["/page-a", "/page-b"]
  }]
}
</script>
```

JSON 객체는 하나 이상의 작업(현재는 prefetch 및 prerender만 지원)과 해당 작업과 관련된 URL 목록을 설명합니다. 위의 HTML 스니펫에서는 브라우저에게 /page-a와 /page-b를 미리 가져오도록 지시합니다. `<link rel="prefetch">`와 유사하게, 추측 규칙은 특정 상황에서 브라우저가 무시할 수 있는 힌트입니다.

> [!NOTE]
> `<link rel="prefetch">`는 리소스를 미리 가져와 HTTP 캐시에 저장하지만, 추측 규칙을 사용하여 로드된 prefetch는 메모리 캐시에 처리 및 저장되어 필요할 때 더 빠르게 검색할 수 있습니다.

Quicklink과 같은 라이브러리는 사용자의 뷰포트 내에 보일 때 페이지로의 링크를 동적으로 미리 가져오거나 사전 렌더링하여 페이지 탐색을 개선합니다. 이는 페이지의 모든 링크를 미리 가져오는 것과 비교하여 사용자가 해당 페이지로 탐색할 가능성을 높입니다.

> [!IMPORTANT]
> 리소스를 미리 가져오면 사용자가 사용되지 않을 수 있는 리소스를 다운로드하게 될 수 있습니다. 리소스를 미리 가져올 때는 필요한 경우에만, 빠른 연결에서만 사용하고, 사용자가 데이터 절약 신호를 활성화한 경우에는 미리 가져오기를 피해야 합니다.

페이지 사전 렌더링

리소스를 미리 가져오는 것 외에도 사용자가 페이지로 탐색하기 전에 페이지를 사전 렌더링하도록 브라우저에 힌트를 줄 수도 있습니다. 이렇게 하면 페이지와 리소스가 백그라운드에서 가져오고 처리되므로 거의 즉각적인 페이지 로드를 제공할 수 있습니다. 사용자가 페이지로 탐색하면 페이지가 전경에 배치됩니다.

사전 렌더링은 Speculation Rules API를 통해 지원됩니다:

```html
<script type="speculationrules">
{
  "prerender": [
    {
      "source": "list",
      "urls": ["/page-a", "page-b"]
    }
  ]
}
</script>
```

> [!NOTE]
> Chrome은 `<link rel="prerender" href="/page">` 리소스 힌트도 지원합니다. 그러나 Chrome 63 이후로 이는 페이지를 렌더링하고 JavaScript를 실행하는 대신 페이지에 필요한 리소스를 가져오는 NoState Prefetch를 시작합니다.

> [!IMPORTANT]
> 전체 사전 렌더링은 사전 렌더링되는 페이지의 JavaScript도 실행합니다. JavaScript는 상당히 크고 계산 비용이 많이 드는 리소스 유형일 수 있으므로, `prerender`는 사용자가 사전 렌더링된 페이지로 탐색할 의도가 확실한 경우에만 신중하게 사용하는 것이 좋습니다.

미리 가져오기 및 사전 렌더링 데모

## 서비스 워커 사전 캐싱

서비스 워커를 사용하여 리소스를 추측적으로 미리 가져올 수도 있습니다. 서비스 워커 사전 캐싱은 Cache API를 사용하여 리소스를 가져오고 저장할 수 있으며, 브라우저가 네트워크에 접속하지 않고 Cache API를 사용하여 요청을 제공할 수 있습니다. 서비스 워커 사전 캐싱은 캐시 전용 전략으로 알려진 매우 효과적인 서비스 워커 캐싱 전략을 사용합니다. 이 패턴은 리소스가 서비스 워커 캐시에 배치되면 요청 시 거의 즉시 가져오기 때문에 매우 효과적입니다.

![서비스 워커 사전 캐싱](/img/service-worker-precaching.png)

*캐시 전용 전략은 서비스 워커 설치 중에만 네트워크에서 적격 리소스를 검색합니다. 설치 후에는 캐시된 리소스만 서비스 워커 캐시에서 검색됩니다.*

> [!IMPORTANT]
> 가까운 미래에 서비스 워커가 제공할 수 있는 다양한 성능 최적화, 예를 들어 런타임 캐싱에 대한 자세한 내용을 다루는 모듈이 계획되어 있습니다.

서비스 워커를 사용하여 리소스를 사전 캐싱하려면 Workbox를 사용할 수 있습니다. 그러나 선호하는 경우, 미리 결정된 파일 세트를 캐시하기 위해 자체 코드를 작성할 수 있습니다. 서비스 워커를 사용하여 리소스를 사전 캐싱하는 방법을 선택하든, 사전 캐싱은 서비스 워커가 설치될 때 발생한다는 것을 아는 것이 중요합니다. 설치 후, 사전 캐싱된 리소스는 웹사이트의 서비스 워커가 제어하는 모든 페이지에서 검색할 수 있습니다.

> [!IMPORTANT]
> 물론 자체 서비스 워커를 처음부터 작성할 수 있지만, Workbox를 사용하면 특히 사전 캐싱에 유용합니다. Workbox는 캐시된 리소스의 버전 정보를 추적합니다. 그런 다음, 향후 서비스 워커를 업데이트하면 Workbox는 만료된 항목을 자동으로 캐시에서 제거하여 직접 수행하는 데 필요한 노력을 절약합니다.

Workbox는 사전 캐싱할 리소스를 결정하기 위해 사전 캐시 매니페스트를 사용합니다. 사전 캐시 매니페스트는 사전 캐싱할 리소스에 대한 "진실의 원천" 역할을 하는 파일 및 버전 정보 목록입니다.

```json
[{
    url: 'script.ffaa4455.js',
    revision: null
}, {
    url: '/index.html',
    revision: '518747aa'
}]
```

위의 코드는 script.ffaa4455.js와 /index.html을 포함하는 예제 매니페스트입니다. 리소스에 파일 자체에 버전 정보(파일 해시라고 함)가 포함된 경우, revision 속성은 null로 남길 수 있습니다. 예를 들어, 위의 코드에서 script.ffaa4455.js 리소스의 경우 ffaa4455입니다. 버전이 없는 리소스의 경우, 빌드 시점에 대한 revision을 생성할 수 있습니다.

설정이 완료되면 서비스 워커를 사용하여 정적 페이지 또는 하위 리소스를 사전 캐싱하여 후속 페이지 탐색 속도를 높일 수 있습니다.

```javascript
workbox.precaching.precacheAndRoute([
  '/styles/product-page.ac29.css',
  '/styles/product-page.39a1.js',
]);
```

예를 들어, 전자 상거래 제품 목록 페이지에서 서비스 워커를 사용하여 제품 세부 정보 페이지를 렌더링하는 데 필요한 CSS 및 JavaScript를 사전 캐싱하여 제품 세부 정보 페이지로의 탐색을 훨씬 빠르게 느낄 수 있습니다. 위의 예에서 product-page.ac29.css와 product-page.39a1.js가 사전 캐싱됩니다. workbox-precaching에서 사용할 수 있는 precacheAndRoute 메서드는 필요할 때마다 서비스 워커 API에서 사전 캐싱된 리소스를 가져오도록 필요한 핸들러를 자동으로 등록합니다.

서비스 워커는 널리 지원되므로, 상황에 따라 필요한 경우 모든 최신 브라우저에서 서비스 워커 사전 캐싱을 사용할 수 있습니다.

> [!NOTE]
> 서비스 워커가 사용하는 Cache 인터페이스와 HTTP 캐시는 동일하지 않습니다. Cache 인터페이스는 JavaScript에 의해 제어되는 고급 캐시인 반면, HTTP 캐시는 Cache-Control 헤더에 의해 제어되는 저급 캐시입니다.

> 리소스 힌트 또는 추측 규칙을 사용하여 리소스를 미리 가져오거나 사전 렌더링하는 것과 유사하게, 서비스 워커 사전 캐싱은 네트워크 대역폭, 저장소 및 CPU를 소비합니다. 사용될 가능성이 높은 리소스만 사전 캐싱하고, 사전 캐시 매니페스트에 너무 많은 리소스를 지정하지 않는 것이 좋습니다. 의심스러운 경우, 너무 많이 사전 캐싱하기보다는 너무 적게 사전 캐싱하고, 속도와 리소스 신선도를 균형 있게 유지하기 위해 다양한 패턴 중 하나를 사용하여 런타임 캐싱에 의존하는 것이 좋습니다. 리소스를 사전 캐싱할 때 해야 할 일과 하지 말아야 할 일에 대한 자세한 내용은 사전 캐싱의 해야 할 일과 하지 말아야 할 일을 읽어보세요.

## 지식을 테스트하세요

- prefetch 힌트는 어떤 우선 순위로 발생합니까?  

  ◯ 높음  
  ◯ 중간  
  ◯ 낮음

- 페이지를 미리 가져오는 것과 사전 렌더링하는 것의 차이점은 무엇입니까?  
  ◯ 둘 다 거의 비슷하지만, prerender는 페이지의 모든 하위 리소스를 가져오고, prefetch는 그렇지 않습니다.  
  ◯ 페이지와 모든 하위 리소스를 가져오는 것은 prefetch와 prerender 모두 동일하지만, prefetch는 페이지와 모든 리소스를 가져오는 것만 수행하고, prerender는 사용자가 페이지로 탐색할 때까지 백그라운드에서 전체 페이지를 렌더링합니다.

- 서비스 워커 캐시와 HTTP 캐시는 동일합니까?  
  ◯ 아니요  
  ◯ 예

## 다음: 웹 워커 개요

이제 미래 페이지로의 탐색 속도를 높이는 데 prefetching, prerendering 및 서비스 워커 사전 캐싱이 얼마나 유용한지 알게 되었으므로, 이를 웹사이트와 사용자에게 어떻게 유용하게 활용할 수 있을지에 대한 교육적인 결정을 내릴 수 있는 위치에 있습니다.

다음으로, 웹 워커에 대한 개요와 웹 워커가 메인 스레드에서 비싼 작업을 제거하고 사용자 상호작용을 위한 메인 스레드에 더 많은 여유 공간을 제공할 수 있는 방법에 대해 설명합니다. 메인 스레드에 더 많은 여유 공간을 제공하기 위해 무엇을 할 수 있는지 궁금하다면, 다음 두 모듈은 시간을 투자할 가치가 있습니다!
