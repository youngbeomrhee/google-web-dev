# 웹 워커 개요

> [!NOTE]
> 이 모듈은 웹 워커의 동작을 높은 수준에서 다룹니다. 포괄적인 설명이라기보다 개요와, 성능을 어떻게 개선할 수 있는지에 대한 데모를 제공합니다. 더 깊이 있는 내용이 필요하다면 `Use web workers to run JavaScript off the browser's main thread` 문서를 참고하세요.

이 코스에서 지금까지 다룬 내용은 일반적인 HTML 성능 고려사항, 리소스 힌트, 초기 페이지 로드 시간과 사용자 입력 반응성을 개선하기 위한 다양한 리소스 최적화, 그리고 특정 리소스의 지연 로딩 같은 개념에 초점을 맞추었습니다.

하지만 JavaScript와 관련된 성능 측면에서 아직 다루지 않은 부분이 있습니다. 바로 입력 반응성 향상에 있어 웹 워커가 하는 역할로, 본 모듈과 다음 모듈에서 이를 다룹니다.

JavaScript는 흔히 단일 스레드 언어라고 설명됩니다. 실제로 이는 브라우저가 브라우저에서 보이는 대부분의 작업을 수행하는 단일 스레드인 메인 스레드를 가리킵니다. 여기에는 스크립팅, 일부 렌더링 작업, HTML/CSS 파싱, 사용자 경험을 좌우하는 기타 사용자 지향 작업 등이 포함됩니다. 실제로 브라우저는 GPU 스레드처럼 개발자가 직접 접근하지 않는 다른 스레드를 사용하기도 합니다.

JavaScript는 기본적으로 메인 스레드에서 작업을 수행하지만, 추가 스레드를 등록해 사용할 수도 있습니다. JavaScript에서 멀티 스레딩을 가능하게 하는 기능을 웹 워커 API(Web Workers API)라고 합니다.

웹 워커는 계산량이 많은 작업을 메인 스레드에서 실행하면 긴 작업이 발생해 페이지가 반응하지 않게 되는 경우에 유용합니다. 이런 작업은 웹사이트의 INP(Interaction to Next Paint)에 부정적 영향을 줄 수 있으므로, 메인 스레드가 아닌 곳에서 수행할 수 있는 작업을 파악하는 것이 도움이 됩니다. 그렇게 하면 메인 스레드에 다른 작업을 위한 여유 공간이 생겨 사용자 상호작용이 더 빨라집니다.

이 모듈과 이어지는 데모는 웹 워커의 구체적인 사용 사례를 보여줍니다. 데모에서는 JPEG 파일의 이미지 메타데이터를 메인 스레드가 아닌 워커에서 읽고, 그 메타데이터를 메인 스레드로 전달해 사용자에게 보여주는 방법을 설명합니다.

## 웹 워커 시작 방법

웹 워커는 `Worker` 클래스를 인스턴스화하여 등록합니다. 이때 브라우저가 로드할 웹 워커 코드의 위치를 지정하며, 브라우저는 해당 코드를 로드하고 새로운 스레드를 생성합니다. 이렇게 생성된 스레드를 보통 워커 스레드라고 합니다.

```javascript
const myWebWorker = new Worker('/js/my-web-worker.js');
```

이후 워커의 JavaScript 파일(여기서는 `my-web-worker.js`)에서 별도의 워커 스레드에서 실행될 코드를 작성합니다.

## 웹 워커의 제한사항

메인 스레드에서 실행되는 JavaScript와 달리, 웹 워커는 `window` 컨텍스트에 직접 접근할 수 없으며 해당 컨텍스트가 제공하는 API 접근도 제한됩니다. 웹 워커에는 다음과 같은 제약이 있습니다:

- 웹 워커는 DOM에 직접 접근할 수 없습니다.
- 웹 워커는 메시징 파이프라인을 통해 `window` 컨텍스트와 통신할 수 있으므로, 간접적으로 DOM에 접근하는 효과를 낼 수 있습니다.
- 웹 워커의 전역 스코프는 `window`가 아니라 `self`입니다.
- 웹 워커 스코프에서는 JavaScript의 기본 타입과 구조체, `fetch`를 포함한 상당수의 웹 API에 접근할 수 있습니다.

## 웹 워커가 window와 통신하는 방법

웹 워커는 메시징 파이프라인을 통해 메인 스레드의 `window` 컨텍스트와 통신할 수 있습니다. 이 파이프라인을 사용하면 메인 스레드와 웹 워커 사이에 데이터를 주고받을 수 있습니다. 웹 워커에서 메인 스레드로 데이터를 보내려면, 웹 워커 컨텍스트(`self`)에서 `message` 이벤트를 설정합니다.

```javascript
// my-web-worker.js
self.addEventListener("message", () => {
  // 웹 워커에서 "Hellow, window!" 메시지를 전송합니다:
  self.postMessage("Hello, window!");
});
```

그런 다음 메인 스레드의 `window` 컨텍스트에서 또 다른 `message` 이벤트를 이용해 웹 워커 스레드로부터 메시지를 수신할 수 있습니다:

```javascript
// scripts.js

// 웹 워커를 생성합니다:
const myWebWorker = new Worker('/js/my-web-worker.js');

// 웹 워커 인스턴스에서 오는 메시지를 수신합니다:
myWebWorker.addEventListener("message", ({ data }) => {
  // 워커로부터 "Hello, window!"를 콘솔에 출력합니다.
  console.log(data);
});
```

> [!NOTE]
> 단순한 작업이라면 웹 워커의 메시징 파이프라인을 직접 사용하는 것으로 충분합니다. 그러나 작업이 복잡해지기 시작할 때 이를 단순화하고 싶다면, [Comlink](https://github.com/GoogleChromeLabs/comlink) 같은 추상화 도구가 유용할 수 있습니다.

웹 워커의 메시징 파이프라인은 웹 워커 컨텍스트에서 벗어나기 위한 일종의 탈출구입니다. 이를 통해 웹 워커에서 메인 스레드의 `window`로 데이터를 전송하고, DOM 업데이트나 메인 스레드에서만 가능한 다른 작업을 수행할 수 있습니다.

## 지식을 테스트하세요

- 웹 워커는 어떤 스레드에서 실행되나요?  
  ◯ GPU 스레드  
  ◯ 메인 스레드  
  ◯ 자체 스레드(웹 워커 스레드)  

- 웹 워커가 접근할 수 있는 것은 무엇인가요?  
  ◯ `window` 컨텍스트(단, 간접적으로만)  
  ◯ `fetch`를 포함한 `window` 컨텍스트의 API 중 엄격하게 제한된 하위 집합  
  ◯ 배열, 객체 등 JavaScript 기본 타입과 구조체  

- 웹 워커가 `window` 컨텍스트에 접근하는 방법은 무엇인가요?  
  ◯ `window` 객체의 멤버를 직접 참조한다  
  ◯ 웹 워커 컨텍스트(`self`)의 `postMessage`로 제공되는 메시징 파이프라인을 사용한다  
  ◯ 어떤 방식으로도 `window`에 접근할 수 없다  

## 다음: 구체적인 웹 워커 사용 사례

다음 모듈에서는 구체적인 웹 워커 사용 사례를 자세히 설명하고 시연합니다. 이 모듈에서는 웹 워커를 사용해 지정된 URL에서 JPEG 파일을 가져오고, 웹 워커에서 Exif 메타데이터를 읽은 다음, 그 데이터를 메인 스레드로 보내 사용자에게 표시하는 과정을 다룹니다.


